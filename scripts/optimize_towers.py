#!/usr/bin/env python3
"""
optimize_towers.py

Goal: For each producible item, propose a "tower" plan that limits the number of
external inputs (items fed from other towers or raw resources) to a small number
(default 3). This helps design vertical towers that each produce a single item
and request only a few standardized inputs from other towers.

Approach:
- Load recipes from public/full-recipes.json (generated by scripts/process.py).
- Build a recipe graph and choose a single recipe per output (as in calculate.py).
- For a target item, build a production tree for the desired rate (default 1/min).
- Initial external inputs are the raw resources at the leaves of this tree.
- Iteratively "cut" subtrees by declaring their root items as external inputs to
  the tower (aka, split into sub-towers/modules). Each cut replaces potentially
  many raw leaf types with a single external item, reducing the variety of inputs.
- Prefer cuts that achieve the largest reduction in the number of input types;
  apply penalties to avoid selecting liquids/gases as external inputs; reward
  items that are already used as standardized inputs for other towers to improve
  cross-target consistency.

Outputs:
- If no --target is given, writes ../public/tower-plans.json with an entry per
  producible item: target name, externalInputs (name + perMin), selected modules,
  recipes used, and basic stats.
- If --target is given, prints the single result (text or JSON with --json).

CLI:
  python scripts/optimize_towers.py [--target NAME] [--rate R]
                                   [--max-inputs K] [--avoid-liquids]
                                   [--json]

Notes:
- We work with the same simplification scheme as scripts/calculate.py so names
  are consistent with transformations.json.
- This script does not alter transformations.json; it produces a separate output.
"""
from __future__ import annotations

import argparse
import json
from collections import defaultdict
from dataclasses import dataclass
from typing import Dict, List, Tuple, Set, Optional
from pathlib import Path

# Resolve paths relative to the project root (two levels up from this script)
BASE_DIR = Path(__file__).resolve().parent.parent
RECIPES_PATH = str(BASE_DIR / "public" / "full-recipes.json")
OUTPUT_TOWERS_PATH = str(BASE_DIR / "public" / "tower-plans.json")

# -------------------------- Name handling --------------------------
OUTPUT_NAME_MAP: Dict[str, str] = {}

def basic_simplify(item: str) -> str:
    if not isinstance(item, str):
        return str(item)
    last = item.split('.')[-1]
    s = last
    if s.startswith("Desc_"):
        s = s[len("Desc_"):]
    if s.endswith("_C"):
        s = s[: -len("_C")]
    if s.startswith("Ore"):
        s = s[len("Ore"):]+" Ore"
    # Specific known renames
    if s == "LiquidOil":
        return "Liquid Oil"
    if s == "RawQuartz":
        return "Raw Quartz"
    if s == "Stone":
        return "Limestone"
    if s == "NitrogenGas":
        return "Nitrogen Gas"
    return s

def simplify(item: str) -> str:
    if isinstance(item, str) and item in OUTPUT_NAME_MAP:
        return OUTPUT_NAME_MAP[item]
    return basic_simplify(item)

# -------------------------- Data structures --------------------------
@dataclass
class ItemRate:
    item: str
    perMin: float

@dataclass
class Recipe:
    id: str
    name: str
    inputs: List[ItemRate]
    outputs: List[ItemRate]

@dataclass(eq=False)
class Node:
    item: str                # full id
    name: str                # simplified/friendly name
    rate: float              # per minute required at this point in the tree
    recipe: Optional[Recipe] # None => raw/external leaf
    children: List["Node"]
    # Cached aggregate of raw requirements under this node (name -> perMin)
    raw_map: Dict[str, float]

# -------------------------- Loaders --------------------------

def load_recipes(path: str = RECIPES_PATH) -> List[Recipe]:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    recipes: List[Recipe] = []
    for r in data:
        inputs = [ItemRate(i["item"], float(i["perMin"])) for i in r.get("inputs", [])]
        outputs = [ItemRate(o["item"], float(o["perMin"])) for o in r.get("outputs", [])]
        recipes.append(Recipe(id=r.get("id", ""), name=r.get("name", r.get("id", "")), inputs=inputs, outputs=outputs))
    return recipes


def build_output_name_map(recipes: List[Recipe]) -> Dict[str, str]:
    mapping: Dict[str, str] = {}
    for r in recipes:
        if r.outputs:
            first_item = r.outputs[0].item
            mapping.setdefault(first_item, r.name)
    return mapping


def build_producer_map(recipes: List[Recipe]) -> Dict[str, List[Recipe]]:
    prod: Dict[str, List[Recipe]] = defaultdict(list)
    for r in recipes:
        for out in r.outputs:
            prod[out.item].append(r)
    return prod

# -------------------------- Recipe choice --------------------------

def choose_recipe_for_item(item: str, producers: Dict[str, List[Recipe]]) -> Optional[Recipe]:
    candidates = producers.get(item)
    if not candidates:
        return None
    def out_rate_for(r: Recipe) -> float:
        for o in r.outputs:
            if o.item == item:
                return o.perMin
        return 0.0
    def sort_key(r: Recipe):
        is_single_output_for_target = (len(r.outputs) == 1 and any(o.item == item for o in r.outputs))
        return (1 if is_single_output_for_target else 0, out_rate_for(r))
    candidates = sorted(candidates, key=sort_key, reverse=True)
    return candidates[0]

# -------------------------- Liquids detection --------------------------
LIQUID_HINTS = {
    "liquid", "gas", "water", "oil", "fuel", "acid", "solution" , "nitrogen", "sulfuric"
}

def is_liquid_like(name: str) -> bool:
    n = name.lower()
    return any(tok in n for tok in LIQUID_HINTS)

# -------------------------- Build production tree --------------------------

def build_tree(item: str, rate: float, producers: Dict[str, List[Recipe]],
               memo: Dict[Tuple[str, float], Node] | None = None,
               path: Set[str] | None = None) -> Node:
    if memo is None:
        memo = {}
    if path is None:
        path = set()
    key = (item, round(rate, 6))
    if key in memo:
        return memo[key]
    # Cycle guard: treat as external
    if item in path:
        node = Node(item=item, name=simplify(item), rate=rate, recipe=None, children=[], raw_map={simplify(item): rate})
        memo[key] = node
        return node

    recipe = choose_recipe_for_item(item, producers)
    if recipe is None:
        # Raw/external leaf
        node = Node(item=item, name=simplify(item), rate=rate, recipe=None, children=[], raw_map={simplify(item): rate})
        memo[key] = node
        return node

    # find output rate for this item
    out_rate = None
    for o in recipe.outputs:
        if o.item == item:
            out_rate = o.perMin
            break
    if not out_rate or out_rate <= 0:
        # Defensive: treat as raw
        node = Node(item=item, name=simplify(item), rate=rate, recipe=None, children=[], raw_map={simplify(item): rate})
        memo[key] = node
        return node

    scale = rate / out_rate
    children: List[Node] = []
    agg: Dict[str, float] = defaultdict(float)

    for inp in recipe.inputs:
        needed = inp.perMin * scale
        child = build_tree(inp.item, needed, producers, memo, path | {item})
        children.append(child)
        for k, v in child.raw_map.items():
            agg[k] += v

    node = Node(item=item, name=simplify(item), rate=rate, recipe=recipe, children=children, raw_map=dict(agg))
    memo[key] = node
    return node

# -------------------------- Optimization (cut selection) --------------------------

def compute_external_inputs_after_cuts(root: Node, cuts: Set[Node]) -> Dict[str, float]:
    """Compute external inputs map when treating each node in cuts as an external input
    (i.e., do not expand into its raw_map; instead request its own item at its rate)."""
    ext: Dict[str, float] = defaultdict(float)

    def walk(n: Node):
        if n in cuts or n.recipe is None:
            # Either selected as external module, or raw leaf
            ext[n.name] += n.rate
            return
        for c in n.children:
            walk(c)

    walk(root)
    # cleanup tiny values
    return {k: round(v, 6) for k, v in ext.items() if abs(v) > 1e-9}


def compute_leaf_occurrences_after_cuts(root: Node, cuts: Set[Node]) -> Dict[str, int]:
    """Count how many external-leaf occurrences of each input type remain when applying cuts.
    Each raw leaf contributes 1 occurrence; each cut node contributes 1 occurrence of its own item."""
    occ: Dict[str, int] = defaultdict(int)

    def walk(n: Node):
        if n in cuts or n.recipe is None:
            occ[n.name] += 1
            return
        for c in n.children:
            walk(c)
    walk(root)
    return dict(occ)


# -------------------------- Boundary complexity --------------------------
# We always prefer “lower” materials at the tower boundary when the number of
# distinct inputs does not decrease. This simple heuristic scores items by how
# deep/advanced they are. Lower score == simpler/lower‑level.
_ITEM_COMPLEXITY_OVERRIDES: Dict[str, float] = {
    # Very low
    "Iron Ore": 1.0,
    "Copper Ore": 1.0,
    "Caterium Ore": 1.0,
    "Bauxite": 1.0,
    "Coal": 1.0,
    "Raw Quartz": 1.0,
    "Sulfur": 1.0,
    "Limestone": 1.0,
    # Low
    "Iron Ingot": 2.0,
    "Copper Ingot": 2.0,
    "Caterium Ingot": 2.5,
    # Basic refinery
    "Plastic": 3.0,
    "Rubber": 3.0,
    "Fuel": 4.0,
    "Polymer Resin": 3.5,
    # Simple parts
    "Wire": 3.5,
    "Cable": 3.8,
    "Iron Rod": 3.8,
    "Iron Plate": 4.0,
    "Reinforced Iron Plate": 5.5,
    "Screw": 4.0,
    "Copper Sheet": 4.0,
    "Concrete": 3.5,
    # Mid components
    "Rotor": 6.0,
    "Modular Frame": 6.5,
    "Circuit Board": 7.0,
    # High‑tech / advanced
    "Computer": 9.0,
    "Heavy Modular Frame": 9.0,
    "AI Limiter": 8.0,
    "High-Speed Connector": 8.5,
    "Motor": 8.0,
    "Turbo Motor": 10.0,
}

_SIMPLE_NAME_HINTS = [
    ("Ore", 1.0),
    ("Ingot", 2.0),
    ("Sheet", 4.0),
    ("Wire", 3.5),
    ("Cable", 3.8),
    ("Rod", 3.8),
    ("Plate", 4.0),
    ("Screw", 4.0),
    ("Frame", 6.5),
    ("Computer", 9.0),
    ("Board", 7.0),
]


def item_complexity(name: str, avoid_liquids: bool) -> float:
    # Exact override first
    if name in _ITEM_COMPLEXITY_OVERRIDES:
        base = _ITEM_COMPLEXITY_OVERRIDES[name]
    else:
        # Fallback: guess from simple tokens in the friendly name
        base = 5.0
        for tok, w in _SIMPLE_NAME_HINTS:
            if tok.lower() in name.lower():
                base = min(base, w)
    # Liquids/gases are harder to handle at boundaries
    if is_liquid_like(name):
        base += 2.0 if avoid_liquids else 1.0
    return float(base)


def boundary_complexity(ext_map: Dict[str, float], avoid_liquids: bool) -> float:
    # Aggregate complexity over distinct types (variety is primary target; rate doesn’t change category)
    return sum(item_complexity(n, avoid_liquids) for n in ext_map.keys())


def gather_candidate_nodes(root: Node) -> List[Node]:
    """All internal nodes (with a recipe) except the root itself are candidates."""
    out: List[Node] = []
    def walk(n: Node, is_root=False):
        if not is_root and n.recipe is not None:
            out.append(n)
        for c in n.children:
            walk(c, False)
    walk(root, True)
    # De-duplicate by object identity (tree may share memoized subtrees for same item+rate)
    # But our build_tree memoizes only exact (item, rate), so within a single build it's fine.
    return out


def seed_preferred_cuts(root: Node, preferred: Set[str]) -> Set[Node]:
    """Return an initial set of cuts for nodes whose base item name is in preferred."""
    cuts: Set[Node] = set()
    def walk(n: Node, is_root=False):
        if not is_root and n.recipe is not None:
            base = basic_simplify(n.item)
            if base in preferred:
                cuts.add(n)
        for c in n.children:
            walk(c, False)
    walk(root, True)
    return cuts


def optimize_cuts(root: Node, max_inputs: int, avoid_liquids: bool,
                  global_pref: Dict[str, int], preferred: Optional[Set[str]] = None) -> Tuple[Set[Node], Dict[str, float]]:
    """Greedy selection of cuts to reduce number of external input types to <= max_inputs.
    Enhanced scoring considers both type-count reduction and reduction in the
    number of leaf occurrences, so the algorithm can make progress even when a
    single cut doesn't immediately drop the distinct-type count.

    Scoring per candidate node N:
      gain_types = |types_before| - |types_after|
      gain_occ   = sum_occ_before - sum_occ_after   (over all input types)
      penalty    = 1.25 if avoid_liquids and is_liquid_like(N.name) else 0.0
      bonus      = 0.25 * global_pref.get(N.name, 0)
      score      = gain_types * 1.0 + gain_occ * 0.05 - penalty + bonus

    Picks the best positive score each iteration. Stops when no positive score
    remains or inputs <= max_inputs.
    Returns the selected cuts set and the final external input map.
    """
    cuts: Set[Node] = set()

    # Seed cuts with preferred modules (e.g., direct inputs of the target)
    if preferred:
        cuts |= seed_preferred_cuts(root, preferred)

    def ext_types_with(cuts_s: Set[Node]) -> Set[str]:
        return set(compute_external_inputs_after_cuts(root, cuts_s).keys())

    def occ_with(cuts_s: Set[Node]) -> Dict[str, int]:
        return compute_leaf_occurrences_after_cuts(root, cuts_s)

    current_ext = compute_external_inputs_after_cuts(root, cuts)
    current_types = set(current_ext.keys())
    current_occ = occ_with(cuts)

    candidates = gather_candidate_nodes(root)

    # Safety cap to avoid excessive loops on very large trees
    max_iters = 100
    iters = 0

    while len(current_types) > max_inputs and iters < max_iters:
        iters += 1
        best_node: Optional[Node] = None
        best_score: float = 0.0

        # Current boundary complexity (we prefer lower materials when type count ties)
        current_complexity = boundary_complexity(current_ext, avoid_liquids)

        tier1: List[Tuple[float, Node]] = []  # gain_types>0 and comp_gain>=0
        tier2: List[Tuple[float, Node]] = []  # gain_types>0 (comp_gain may be <0)
        tier3: List[Tuple[float, Node]] = []  # gain_types==0 and comp_gain>0

        for cand in candidates:
            if cand in cuts:
                continue
            trial_cuts = cuts | {cand}
            ext_after_map = compute_external_inputs_after_cuts(root, trial_cuts)
            types_after = set(ext_after_map.keys())
            occ_after = occ_with(trial_cuts)
            gain_types = len(current_types) - len(types_after)
            # total occurrence reduction
            sum_before = sum(current_occ.values())
            sum_after = sum(occ_after.values())
            gain_occ = max(0, sum_before - sum_after)
            # complexity improvement
            comp_after = boundary_complexity(ext_after_map, avoid_liquids)
            comp_gain = current_complexity - comp_after
            # extra credit for eliminating liquid types from the external set
            liquid_removed = 0
            if avoid_liquids:
                for t in current_types:
                    if is_liquid_like(t) and t not in types_after:
                        liquid_removed += 1
            penalty = 1.25 if avoid_liquids and is_liquid_like(cand.name) else 0.0
            bonus = 0.25 * global_pref.get(cand.name, 0)
            complexity_penalty = 0.15 * item_complexity(cand.name, avoid_liquids)
            # Score prioritizes reducing distinct types; when equal, prefer lower complexity boundaries; avoid selecting very advanced modules as cuts
            score = gain_types * 1.0 + comp_gain * 0.6 + gain_occ * 0.03 + liquid_removed * 2.0 - penalty + bonus - complexity_penalty

            if gain_types > 0 and comp_gain >= 0:
                tier1.append((score, cand))
            elif gain_types > 0:
                tier2.append((score, cand))
            elif gain_types == 0 and comp_gain > 0:
                tier3.append((score, cand))

        # Prefer candidates that reduce types without increasing complexity; then others that reduce types; then equal-type reductions with lower complexity
        def pick_best(lst: List[Tuple[float, Node]]) -> Tuple[Optional[Node], float]:
            if not lst:
                return None, 0.0
            lst.sort(key=lambda x: x[0], reverse=True)
            return lst[0][1], lst[0][0]

        best_node, best_score = pick_best(tier1)
        if best_node is None:
            best_node, best_score = pick_best(tier2)
        if best_node is None:
            best_node, best_score = pick_best(tier3)

        if best_node is None or best_score <= 0:
            # Cannot improve further
            break
        cuts.add(best_node)
        # refresh current inputs/types/occ/complexity
        current_ext = compute_external_inputs_after_cuts(root, cuts)
        current_types = set(current_ext.keys())
        current_occ = occ_with(cuts)

    return cuts, current_ext

# -------------------------- Tower planning per target --------------------------

def plan_tower_for_target(target_item: str, rate: float, producers: Dict[str, List[Recipe]],
                          max_inputs: int, max_inputs_soft: int, avoid_liquids: bool,
                          global_pref: Dict[str, int]) -> Dict:
    """Return a serializable dict with the plan for the target.
    Strategy: try with max_inputs (e.g., 3); if not achievable, retry with
    min(max_inputs_soft, 5)."""
    root = build_tree(target_item, rate, producers)

    # Preferred modules: disabled to favor lower-level boundary materials consistently
    preferred: Optional[Set[str]] = None

    # First attempt
    cuts, ext_map = optimize_cuts(root, max_inputs=max_inputs, avoid_liquids=avoid_liquids, global_pref=global_pref, preferred=preferred)

    achieved_k = len(ext_map)
    soft_used = False
    if achieved_k > max_inputs and max_inputs_soft > max_inputs:
        cuts, ext_map = optimize_cuts(root, max_inputs=max_inputs_soft, avoid_liquids=avoid_liquids, global_pref=global_pref, preferred=preferred)
        achieved_k = len(ext_map)
        soft_used = True

    # Update global preferences: reward chosen external inputs (consistency across towers)
    for name in ext_map.keys():
        global_pref[name] = global_pref.get(name, 0) + 1

    # Collect recipes used within the tower (excluding cut subtrees) for reference
    recipes_used: Set[str] = set()
    def walk_collect(n: Node):
        if n in cuts:
            return
        if n.recipe is not None:
            recipes_used.add(n.recipe.name)
        for c in n.children:
            walk_collect(c)
    walk_collect(root)

    # Prepare modules list (cuts)
    modules = [
        {"name": n.name, "rate": round(n.rate, 6), "isLiquid": is_liquid_like(n.name)}
        for n in sorted(cuts, key=lambda x: x.name)
    ]

    # Prepare external inputs list (aggregated)
    external_inputs = [
        {"name": k, "perMin": round(v, 6), "isLiquid": is_liquid_like(k)}
        for k, v in sorted(ext_map.items())
    ]

    achieved_note = "soft" if soft_used else "hard"

    return {
        "target": simplify(target_item),
        "targetFull": target_item,
        "rate": rate,
        "achievedInputs": achieved_k,
        "goalMax": max_inputs if not soft_used else max_inputs_soft,
        "goalMode": achieved_note,  # 'hard' if within initial K, 'soft' if fell back
        "externalInputs": external_inputs,
        "modules": modules,
        "recipesUsed": sorted(recipes_used),
    }

# -------------------------- CLI / Main --------------------------

def find_unique_output_items(recipes: List[Recipe]) -> Set[str]:
    unique: Set[str] = set()
    for r in recipes:
        for o in r.outputs:
            unique.add(o.item)
    return unique


def main():
    p = argparse.ArgumentParser(description="Optimize tower inputs by selecting module boundaries.")
    p.add_argument("--target", help="Target item to compute (simplified/friendly or full id).")
    p.add_argument("--rate", type=float, default=1.0, help="Target production rate per minute (default 1.0)")
    p.add_argument("--max-inputs", type=int, default=3, help="Hard goal for max external input types (default 3)")
    p.add_argument("--max-inputs-soft", type=int, default=5, help="Soft fallback if hard goal not achievable (default 5)")
    p.add_argument("--avoid-liquids", action="store_true", help="Prefer avoiding liquids/gases as external inputs")
    p.add_argument("--json", action="store_true", help="Output JSON instead of writing tower-plans.json")
    args = p.parse_args()

    recipes = load_recipes(RECIPES_PATH)

    global OUTPUT_NAME_MAP
    OUTPUT_NAME_MAP = build_output_name_map(recipes)

    producers = build_producer_map(recipes)

    # Resolve target(s)
    targets: List[str]
    if args.target:
        # Try to match by friendly/simple name
        all_outputs = list(find_unique_output_items(recipes))
        inp_basic = basic_simplify(args.target)
        inp_friendly = args.target
        candidates = []
        for it in all_outputs:
            names_for_it = {basic_simplify(it), simplify(it)}
            if inp_basic in names_for_it or inp_friendly in names_for_it or args.target == it:
                candidates.append(it)
        if not candidates:
            candidates = [args.target]
        targets = [candidates[0]]
    else:
        targets = sorted(find_unique_output_items(recipes))

    # Global preference for consistency across towers
    global_pref: Dict[str, int] = {}

    plans = []
    for t in targets:
        plan = plan_tower_for_target(
            target_item=t,
            rate=args.rate,
            producers=producers,
            max_inputs=max(1, int(args.max_inputs)),
            max_inputs_soft=max(1, int(args.max_inputs_soft)),
            avoid_liquids=bool(args.avoid_liquids),
            global_pref=global_pref,
        )
        plans.append(plan)

    if args.target:
        if args.json:
            print(json.dumps(plans[0], indent=2))
        else:
            r = plans[0]
            print(f"=== Tower plan for {r['target']} ({r['rate']}/min) ===")
            print(f"Achieved inputs: {r['achievedInputs']} (goal {r['goalMax']} - {r['goalMode']})")
            if not r["externalInputs"]:
                print("  External inputs: (none)")
            else:
                print("  External inputs (per min):")
                for i in r["externalInputs"]:
                    liq = " [liquid]" if i["isLiquid"] else ""
                    print(f"    - {i['name']}: {i['perMin']}{liq}")
            if r["modules"]:
                print("  Modules (sub-towers):")
                for m in r["modules"]:
                    liq = " [liquid]" if m["isLiquid"] else ""
                    print(f"    - {m['name']}: {m['rate']}/min{liq}")
            if r["recipesUsed"]:
                print("  Recipes used internally:")
                for name in r["recipesUsed"]:
                    print(f"    - {name}")
    else:
        with open(OUTPUT_TOWERS_PATH, "w", encoding="utf-8") as f:
            json.dump(plans, f, indent=2)
        print(f"Wrote {len(plans)} tower plans to {OUTPUT_TOWERS_PATH}")


if __name__ == "__main__":
    main()
